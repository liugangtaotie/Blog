### 内存模型

Java内存模型，往往是指Java程序运行在Java虚拟机时内存的模型。

![内存模型](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/jvm-01.png)

运行时数据区的树形结构如下

```
共享数据区
    堆区
    方法区
        常量池
        其他
私有数据区
    程序计数器
    虚拟机栈
    本地方法栈
```

**程序计数器**

程序计数器是一块较小的「线程私有」的内存空间，可以看作当前线程所执行字节码的行号指示器。

在字节码解释器的工作时，就是通过改变程序计数器的值来读取下一条需要执行的字节码指令。比如：分支、循环、跳转、异常处理、线程恢复等

如果线程正在执行一个Java方法，则此计数器记录正在执行的虚拟机字节码指令地址；如果线程正在执行的是Native方法，则此计数器值为空（undefined）。此内存区域是唯一没有OOM情况的区域。

**虚拟机栈**

每个方法在执行的同时会创建一个*栈帧*，用来存储：局部变量表、操作数栈、动态链接、方法出口、等信息。

局部变量表是在编译期间完成内存分配，存放了各种基本数据类型和对象引用。

如果线程请求栈深度大于当前虚拟机所允许深度，会抛出StackOverflowError异常；如果虚拟机无法申请到足够的内存，会抛出OutOfMemoryError异常。

**本地方法栈**

虚拟机栈是为虚拟机执行Java方法服务，本地方法栈是为虚拟机Native方法服务。

同虚拟机栈一样，本地方法栈也可能会抛出StackOverflowError和OutOfMemoryError异常。

**Java堆**

> The heap is the runtime data area from which memory for all class instances and arrays is allocated

几乎所有的对象示例都在这里分配内存。（随着编译器的发展以及逃逸分析技术的成熟，所有的对象分配在堆上也不是那么「绝对」了）

**方法区**

存储已被虚拟机加载的类信息、常量、静态变量、即时编译后代码等数据。

虽然Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它的别名是`Non-Heap`，就是想跟Java堆区分开来。

**常量池**

是方法区的一部分，用于存放编译器时期生成的各种常量。常量池具备动态性，运行期间可以通过`str.intern()`动态存放常量到池中。

**直接内存**

JDK 1.4 以后加入了NIO(New Input/Output)类，引入了基于通道的I/O方式，可以使用Native函数库分配堆外内存。
