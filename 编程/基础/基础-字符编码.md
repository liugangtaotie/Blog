## 字符编码

**以前一直不明白字符编码之间的关系，今天就把这个知识点消化掉。**

### 编码历史小故事

[转自知乎](https://www.zhihu.com/question/23374078/answer/69732605)

很久很久以前，有一群人，看到中国的八卦，从中受到启发，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。

开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。

后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！

等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。

但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”

因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序
就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！

正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。

unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。

unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，**UTF-8就是每次8个位传输数据**。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中
文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

### ASCII码

ASCII编码(American Standard Code for Information Interchange)。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

### ISO-8859-1（Latin1）

由于ASCII码主要是为了表示英文字符而设计的，因此用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，因此就无法用ASCII码表示。于是ISO组织在ASCII码基础上上扩展了ASCII编码，它们是ISO-8859-1~ISO-8859-15，其中ISO-8859-1覆盖了大多数西欧语言字符，所以应用得最广泛。

ISO-8859-1仍然是单字节编码，它总共能表示256个字符。ISO-8859-1向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。另外，欧元符号出现的比较晚，没有被收录在ISO-8859-1当中。

ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。所以，Latin1是ISO-8859-1的别名。因为ISO-8859-1编码使用了单字节内的所有空间，因此把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。因此，MySQL数据库默认编码是Latin1

### ANSI

ANSI全称是AMERICAN NATIONAL STANDARDS INSTITUTE，美国国家标准学会。

针对汉字的编码，不同的国家和地区制定了不同的标准，由此产生了GB2312（1980）、GBK（1984）、Big5（香港台湾）、Shift_JIS（日本） 等各自的编码标准。这些使用1至4个字节来代表一个字符的各种汉字延伸编码方式，称为ANSI编码。

在简体中文Windows操作系统中，ANSI编码代表GBK编码；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS编码。相当于计算机内有一个变量控制这台电脑是哪个国家的编码格式。

### GB2312

GB2312编码是由中国国家标准总局1980年发布的第一个汉字编码国家标准，GB2312编码共收录汉字6763个，其中一级汉字3755个，二级汉字3008个。同时，GB2312编码收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。

GB2312编码对所收录字符进行“分区”处理，共94个区，每区含有94个位，共8836个码位。这种表示方式也称为区位码。

```	
01-09区收录除汉字外的682个字符。
10-15区为空白区，没有使用。
16-55区收录3755个一级汉字，按拼音排序。
56-87区收录3008个二级汉字，按部首/笔画排序。
88-94区为空白区，没有使用。
```

GB2312规定对收录的每个字符采用两个字节表示，第一个字节为“高字节”，对应94个区，简称区号；第二个字节为“低字节”，对应94个位，简称位号。所以它的区位码范围是：0101－9494。

**定义：区号和位号分别加上0xA0就是GB2312编码。**

举例来说，“啊”字是GB2312编码中的第一个汉字，它位于16区的01位，所以它的区位码就是1601。区号和位号分别转换成十六进制是1001。那么经过计算 0x10+0xA0=0xB0，0x01+0xA0=0xA1，所以该码位的GB2312编码是B0A1。

### GBK

GBK编码是1995年12月发布的汉字编码国家标准，是对GB2312编码的扩充，对汉字采用双字节编码。GBK字符集共收录21003个汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字。

### BIG5

BIG5编码是1984年台湾地区实施的繁体中文标准字符集，采用双字节编码，共收录13053个中文字。BIG5编码又称大五码，是繁体中文字符集编码标准，共收录13060个中文字，其中有二字为重复编码。

BIG5采用双字节编码，使用两个字节来表示一个字符。高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE。
在BIG5的分区中：

```
8140-A0FE 保留给使用者自定义字符（造字区）
A140-A3BF 标点符号、希腊字母及特殊符号。其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。
A3C0-A3FE 保留（此区没有开放作造字区用）
A440-C67E 常用汉字，先按笔划再按部首排序
C6A1-F9DC 其它汉字
F9DD-F9FE 制表符
```

值得留意的是，BIG5重复地收录了两个相同的字：“兀、兀”（A461及C94A)、“嗀、嗀”(DCD1及DDFC)。

### Unicode

世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。

可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失，这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码字符集。

Unicode不是一次性定义的，而是以2的16次方为一个平面，到目前为止，只有17个平面（2的5次方）个平面，因此可以代表2的21次方个字符，也就是说，整个Unicode字符集的大小现在是2的21次方。最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到2的16次方-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。

每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询[unicode.org](http://www.unicode.org/)，或者专门的[汉字对应表](http://www.chi2ko.com/tool/CJK.htm)。

最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示2的31次方个字符，完全可以涵盖一切语言所用的符号。

### Unicode问题

**Unicode只是一个符号集**，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

**那么怎么区别Unicode和ASCII？**

计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。这个问题直接导致的结果就是

- 出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。
- Unicode在很长一段时间内无法推广，直到互联网的出现。

### UTF-8

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。

**注意：UTF-8只是Unicode的实现方式之一**

其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。

UTF-8最大的特点就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8的编码规则很简单

- 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是完全相同的。
- 对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

编码规则如下表，字母x表示可用编码的位。

|Unicode符号范围（16进制）|UTF-8编码方式（2进制）|可用字节位数
|---|---|---|---|
|0000 0000 - 0000 007F | 0xxxxxxx|7|
|0000 0080 - 0000 07FF | 110xxxxx 10xxxxxx|11|
|0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx|16|
|0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx|21|

根据上表，解读UTF-8编码变得非常简单。

- 如果一个字节的第一位是0，则这个字节单独就是一个字符；
- 如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

**举例说明**

已知「严」的unicode是4E25（0100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此「严」的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从「严」的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，「严」的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。

### UTF-16

UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存。那么为什么UTF-16没有流行起来呢？因为对比UTF-8，UTF-16是定长编码，虽然快速定位字符，但是空间浪费大。而且存取过程中，存在大小端字节序问题。

### Big Endian和Little Endian

第一个字节在前，就是"大头方式"（Big endian），第二个字节在前就是"小头方式"（Little endian）。

**为什么会有大小端模式之分呢？**

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

**那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？**

Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。

### 番外篇：BOM（PS：2016-04-16）

BOM —— Byte Order Mark，中文名译作“字节顺序标记”。

在UCS编码中有一个叫做"Zero Width No-Break Space" ，中文译名作“零宽无间断间隔”的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。UCS 规范建议我们在传输字节流前，先传输字符 "Zero Width No-Break Space"。这样如果接收者收到 FEFF，就表明这个字节流是 Big-Endian 的；如果收到FFFE，就表明这个字节流是 Little- Endian 的。因此字符 "Zero Width No-Break Space" （“零宽无间断间隔”）又被称作 BOM。

UTF-8 不需要BOM来表明字节存储的顺序，但可以用BOM来表明编码方式。字符"Zero Width No-Break Space"的UTF-8编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。

字符U+FEFF如果出现在字节流的开头，则用来标识该字节流的字节序，是高位在前还是低位在前。如果它出现在字节流的中间，则表达零宽度非换行空格的意义，用户看起来就是一个空格。从Unicode3.2开始，U+FEFF只能出现在字节流的开头，只能用于标识字节序，就如它的名称——字节序标记——所表示的一样；除此以外的用法已被舍弃。取而代之的是，使用U+2060来表达零宽度无断空白。

### 举例说明

内容就是一个"严"字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。

然后，用文本编辑软件UltraEdit中的"十六进制功能"，观察该文件的内部编码方式。

- ANSI：文件的编码就是两个字节"D1 CF"，这正是"严"的GB2312编码，"严"的编码高位是D1，存储在低位。这也暗示GB2312是采用大头方式存储的。
- Unicode：编码是四个字节"FF FE 25 4E"，其中"FF FE"表明是小头方式存储，真正的编码是4E25。
- Unicode big endian：编码是四个字节"FE FF 4E 25"，其中"FE FF"表明是大头方式存储。
- UTF-8：编码是六个字节"EF BB BF E4 B8 A5"，前三个字节"EF BB BF"表示这是UTF-8编码，后三个"E4B8A5"就是"严"的具体编码，它的存储顺序与编码顺序是一致的。

### 番外篇：URL编码（PS：2016-04-16）

摘自：http://www.ruanyifeng.com/blog/2010/02/url_encoding.html

- 网络路径中包含汉字。IE浏览器中输入：`http://zh.wikipedia.org/wiki/春节` 会自动编码为 `http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82`
- 查询字符串中包含汉字。IE,FireFox,Chrome可能或多或少有些区别，查看头信息发现是乱码，切换到16进制下，最终发现编码是操作系统的默认编码。
- 汉字在Http Get请求中。由网页编码确定
- Ajax调用的URL包含汉字，每个浏览器编码格式有所不同。

看完是不是头都大了，因为实在是太混乱了，不同操作系统，不同浏览器，不同网页字符，会导致不同的编码结果，有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？

**回答是有的，就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。**

- Javascript函数：escape() 不提倡
	+ 首先，无论网页的原始编码是什么，一旦被Javascript编码，就都变为unicode字符。也就是说，Javascipt函数的输入和输出，默认都是Unicode字符
- Javascript函数：encodeURI()
 	+ 它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号`; / ? : @ & = + $ , #`，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。
- Javascript函数：encodeURIComponent() 推荐
	+ 与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。因此，`; / ? : @ & = + $ , #`，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。

### 感谢

- 阮一峰：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html
- 阮一峰：http://www.ruanyifeng.com/blog/2010/02/url_encoding.html
- 金丝燕王：http://swiftlet.net/archives/category/char-encoding
- 知乎：https://www.zhihu.com/question/23374078/answer/69732605
- Java中文编码：http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/

