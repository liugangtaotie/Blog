## 对象和引用

### 引用计数法

给对象添加一个引用计数器，每当有地方引用它时，计数器值加一；当引用失效时，计数器值减一。

**Java虚拟机并没有使用引用计数器算法来管理内存，因为他很难解决对象间相互循环引用的问题。**

为了解决这个问题，出现了*可达性分析*

### 可达性分析算法

通过一系列的称谓「GC Roots」的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象时不可用的。

可作为「GC Roots」的对象有以下几种

- 虚拟机栈引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

### 引用类型

- 强引用:常见普遍存在的引用关系。
- 软引用(SoftReference):在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常。
- 弱引用(WeakReference):当GC时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象。
- 虚引用(PhantomReference):幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 垃圾收集算法

### 标记清除算法

*Mark-Sweep*算法是最基本的算法（因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的），算法分为「标记」和「清除」两个阶段：

1. 首先标记出所有需要回收的对象。(使用可达性分析对引用进行标记)
2. 在标记完成后统一回收掉所有被标记的对象。

**主要缺点如下**

- 效率：标记和清除过程的效率都不高
- 内存：标记清除之后会产生大量不连续的内存碎片，内存碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次GC动作。 

### 复制算法

*Copying*算法主要解决了效率问题。

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将标记存活着对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

**缺点**：实际可用内存缩小为原来的一半。

### 标记整理

*Mark-Compact*算法，标记过程仍然与「标记-清除」一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

*Generational Collection*算法，是根据对象的存活周期的不同将内存划分为几块。

一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清理」或「标记-整理」算法来进行回收

## 垃圾收集器

### Serial 收集器

串行收集器，Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。它进行垃圾收集时，必须暂停其他所有的工作线程（Stop the world），直到它收集结束。

### Parallel 收集器

并行收集器，Server模式下的默认收集器，是 Serial收集器的多线程版本。它进行垃圾收集时，必须暂停其他所有的工作线程（Stop the world），直到它收集结束。

### Parallel Scavenge 收集器

并行收集器，这是一个新生代收集器，它使用的复制算法，并行的多线程收集器。

与Parallel收集器不同的是，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。

### Serial Old 收集器

Serial收集器的老年代版本。

### Parallel Old 收集器

Parallel Scavenge收集器的老年代版本。

### CMS 收集器

Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目标的收集器。是一款具有划时代意义的*并发*收集器。真正实现了垃圾收集线程和工作线程同时进行。

使用更为复杂的「标记-清除」算法实现，大致步骤如下。

1. 初始标记
2. 并发表及
3. 重新标记
4. 并发清除

其中初始标记和重新标记仍然需要Stop the world。

有三个主要*缺点*如下

1. 对CPU资源敏感
2. 无法处理浮动垃圾
3. 产生大量内存碎片（如果开启碎片整理，则GC时间变长）

### G1 收集器

G1收集器基于「标记-整理」算法实现。当前最新最优秀的收集器之一。有如下优点

1. 并行与并发
2. 分代收集
2. 空间整合
4. 可预测的停顿：可指定垃圾收集器上消耗的时间。

## 内存分配策略

- 对象优先在新生代Eden区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

### Minor GC 和 Full GC 不同之处

- Minor GC 是指发生在新生代的垃圾收集动作，速度快且频率高

- Full GC 是指发生在老年代的GC，速度慢且频率低