## 概述

**TCP 特点**

- 提供一种面向连接的的运输层协议
- 点对点通信
- 提供可靠交付服务（无差错、不丢失、不重复、按序到达）
- 面向字节流
- 提供全双工通信

**全双工通信**

- 全双工：两根数据管道，一根用来传输，一根用来接收。（公路的双行道）
- 半双工：一根数据管道，同一时间段只能用来传输或接收（公路的单边放行）
- 单工：只允许A→B传送信息，而不能B→A传送 。（公路的单行道）

**套接字（socket）**：即TCP连接的端点，表示为 `(IP:port)`

**TCP连接**：{(IP1:port1),(IP2:port2)}

**socket名词意思分类**

- 应用接口编程 API
- socket API 中使用的函数 socket
- 调用函数的断点也叫 socket
- 调用函数的返回值成为 socket 描述符
- 操作系统内核联网协议的实现 称为 socket 实现

## TCP 通信过程概览图

![通信过程概览](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-03.png)

## TCP 报文段

在深入了解 TCP 的可靠传输前，必须先了解 TCP 报文段。

### TCP 报文段首部格式

TCP 是面向字节流的，但传送的数据单元却是报文段。一个报文段分为首部和数据两部分，TCP 报文段首部的前20个字节是固定的，后面有 4N 字节根据需要增加。

![首部格式](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-04.png)

**源端口（Source Port）目的端口（Destination Port）各2字节**

源端口号标识主机上发起传送的应用程序端口号；目的端口标识主机上传送要到达的应用程序端口号

**序列号（Sequence Number）4字节**

也叫做「报文段序号」，该字段用来标识 TCP 发送的字节流的每一个字节的序号。理论上有[0,2^32-1]个字节（4G）。

**确认号（Acknowledge Number）4字节**

是期望收到对方下一个报文段的第一个数据字节的序号

**数据偏移（Data Offset）占4位 0.5个字节**

指的是 TCP 报文段的数据起始处距整个 TCP 报文段的起始处有多远。

数据偏移的单位不是字节而是32bit，因此 TCP 头部的范围为 `[20,(2^4-1)*4]` 字节，即选项长度不能超过40字节

**保留（Reserved）占6位** 目前置为0，为将来定义新的用途保留。

**控制位(ControlBits)占6位** 每一位标志可以打开一个控制功能。

- URG（Urgent Pointer Field Significant,紧急指针字段标志）:表示TCP包的紧急指针字段有效，用来保证TCP连接不被中断，并且督促中间齐备尽快处理这些数据。
- ACK（Acknowledgement field significant,确认字段标志）:取1时表示应答字段有效，也即TCP应答号将包含在TCP段中，为0则反之。
- PSH（Push Function,推功能）:这个标志表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即送给应用程序，而不是在缓冲区中排队。
- RST（Reset the connection,重置连接）：这个标志表示感谢连接复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。
- SYN（Synchronize sequence numbers,同步序列号）:表示同步序号，用来建立连接。
- FIN（No more data from sender）:表示发送端已经发送到数据末尾，数据传送完成，发送FIN标志位的TCP段，连接将被断开。

**窗口（Window）占2字节**

窗口值是`[0,2^16-1]`，窗口指的是发送本报文段的目的窗口（接收窗口）。窗口值作为接收方让发送方设置其发送窗口的数据。

简单来说就是，窗口字段用来控制对方发送的数据量，告诉对方主机它每次期望收到的数据量的字节数。最大为65kb。

**校验和（Checksum）占2字节**

校验和字段检验的范围包括首部和数据这两部分，为了证明数据的有效性。

**紧急指针（Urgent Pointer）占2字节**

这个字段只在URG标志被设置时才有效，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。

**选项（Option）**

长度可变，最长为40个字节，当没有使用长度时，TCP 首部长度为 20 个字节。

最大报文段长度MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。

**填充（Padding）**

这个字段中加入额外的零，以保证TCP头是32的整数倍。

### 传输量大小

- TCP 序列号范围 [0,2^32-1]，只是个序号而已，即便发送到了2^32-1个字节，那时候第0个字节早就发送过去了，所以会重新标记序号为0。
- TCP 每次传输包最大为65k
- 数据链路层对数据帧的长度都有一个限制，也就是链路层所能承受的最大数据长度，这个值称为最大传输单元，即 MTU 。MTU 最大长度限制为 1500 字节。如果 IP 包大小超过了 MTU 值，那么就需要对 IP 包分片为多个。

## 可靠传输原理

TCP 发送的报文段是交给 IP 层传输的，IP 层只能提供尽最大努力服务，也就是说 TCP 下面的网络所提供的是不可靠的传输，因此 TCP 需要采用适当的措施使两个运输层之间尽量可靠。

**自动重传请求（Automatic Repeat-reQuest，ARQ）**：是OSI模型中数据链路层和传输层的错误纠正协议之一

### 停止等待 ARQ 协议

每发完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。

### 连续 ARQ 协议

这个协议会连续发送一组数据包，然后再等待这些数据包的 ACK .

1. **回退并重传 ARQ 协议**
- 接收点丢弃从第一个没有收到的数据包开始的所有数据包。
- 发送点收到 NACK 后，从 NACK 中指明的数据包开始重新发送。

2. **选择重传 ARQ 协议**
- 发送点连续发送数据包但对每个数据包都设有个一个计时器。
- 当在一定时间内没有收到某个数据包的 ACK 时，发送点只重新发送那个没有 ACK 的数据包。

## 三次握手（建立连接）

![三次握手](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-01.jpeg)

- 第一次握手 B 知晓 A  可以接收 B 可以发送
- 第二次握手 A 知晓 AB 可以发送 可以接收
- 第三次握手 B 知晓 A  可以接收 B 可以发送

## 四次挥手（关闭连接）

![四次挥手](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-02.jpeg)

- 第一次挥手 A 告诉 B , A 端发送数据完毕，关闭发送数据通道，准备关闭接收数据通道
- 第二次挥手 B 告诉 A , B 端已知道
- 第三次挥手 B 告诉 A , B 端发送数据完毕，关闭发送数据通道，准备关闭接收数据通道
- 第四次挥手 A 告诉 B , A 端已知道，B 端关闭接收数据通道
- 等待2MSL  A 端关闭接收数据通道

**A端为什么要等待 2MSL 的时间才关闭？**

MSL: Maximum Segment Lifetime 报文最大生存时间

- 情况一：A 发送的最后一个 ACK 报文能够到达 B 。如果第四次挥手时，如果 B 没有收到 A 的确认报文，会超时重传第三次挥手的报文。
- 情况二：防止 A 中已经失效的报文出现在这个链接中。

**B端为什么要存在一个保活状态？**

如果第三次挥手完成后，A 突然故障死机了，那 B 的连接资源什么时候能释放呢？因此 B 存在一个保活状态，就是保活时间到了后，B 会发送探测信息，以决定是否释放连接。

## 定时器

- **建立连接定时器(connection-establishment timer)**

三次握手建立连接的过程中，在发送SYN时， 会启动一个定时器(默认应该是3秒)，如果SYN包丢失了，会重新发送 SYN 包。 

- **重传定时器(retransmission timer)**

为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，就创建这个特定报文段的重传计时器。

报文段的往返时间称为 RTT

**延迟应答定时器(delayed ACK timer)**

延迟应答也被成为捎带ACK，这个定时器是在延迟应答的时候使用的。为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。

举例说明，比如服务端收到客户端的数据后，不是立刻回ACK给客户端，而是等一段时间(一般最大200ms)，这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了，这样比立即回给客户端一个ACK节省了一个数据包。

**坚持定时器(persist timer)**

坚持定时器是使用在一方滑动窗口为0之后，另外一方停止传输数据，进入坚持定时器的轮询，直到滑动窗口不再为0了。

发送方使用一个坚持定时器来周期性地向接收方发送窗口探测报文，以便发现窗口是否已增大。用来检测「糊涂窗口综合症」，目的是让发送的数据大于一定的窗口才发送。

**保活定时器(keepalive timer)**

TCP 的 KeepAlive ，目的在于看看对方有没有发生异常，如果有异常就及时关闭连接。跟 Http 中的 KeepAlive 不一样

**FIN_WAIT_2定时器(FIN_WAIT_2 timer)**

A 调用完 close 后，收到 B 的确认 ACK 后，进入 FIN_WAIT_2 状态，如果 A 在这段定时器内没有收到 B 发送的 FIN，那么 A 会关闭连接。

**TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)**

A 发送完确认报文段后，在 2MSL 时间过后，就会关闭连接。

## 滑动窗口协议

滑动窗口协议是 TCP 协议的精髓，TCP 的滑动窗口是以字节为单位的。传输过程比较复杂，这里先写个目录，以后慢慢补充。

### 可靠传输实现
### 流量控制
### 拥塞控制

## 未完待续...

滑动窗口协议

## 参考

- 《计算机网络》
- [ARQ维基百科](https://zh.wikipedia.org/wiki/ARQ)
- [TCP数据报首部](http://blog.chinaunix.net/uid-26413668-id-3408115.html)
- [TCP/IP笔记整理](http://blog.csdn.net/goodboy1881/article/category/204448)
- [三次握手四次挥手](http://blog.csdn.net/whuslei/article/details/6667471)
- [三次握手四次挥手](http://blog.csdn.net/xulu_258/article/details/51146489)
- [TCP定时器](http://www.debugrun.com/a/KqfjJer.html)