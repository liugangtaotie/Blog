## 概述

**TCP 特点**

- 提供一种面向连接的的运输层协议
- 点对点通信
- 提供可靠交付服务（无差错、不丢失、不重复、按序到达）
- 面向字节流
- 提供全双工通信

**全双工通信**

- 全双工：两根数据管道，一根用来传输，一根用来接收。（公路的双行道）
- 半双工：一根数据管道，同一时间段只能用来传输或接收（公路的单边放行）
- 单工：只允许A→B传送信息，而不能B→A传送 。（公路的单行道）

**套接字（socket）**：即TCP连接的端点，表示为 `(IP:port)`

**TCP连接**：{(IP1:port1),(IP2:port2)}

**socket名词意思分类**

- 应用接口编程 API
- socket API 中使用的函数 socket
- 调用函数的断点也叫 socket
- 调用函数的返回值成为 socket 描述符
- 操作系统内核联网协议的实现 称为 socket 实现

## TCP 通信过程概览图

![通信过程概览](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-03.png)

## TCP 报文段

在深入了解 TCP 的可靠传输前，必须先了解 TCP 报文段。

TCP 是面向字节流的，但传送的数据单元却是报文段。一个报文段分为首部和数据两部分，TCP 报文段首部的前20个字节是固定的，后面有 4N 字节根据需要增加。

![首部格式](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-04.png)

**源端口（Source Port）目的端口（Destination Port）各2字节**

源端口号标识主机上发起传送的应用程序端口号；目的端口标识主机上传送要到达的应用程序端口号

**序列号（Sequence Number）4字节**

也叫做「报文段序号」，该字段用来标识 TCP 发送的字节流的每一个字节的序号。理论上有[0,2^32-1]个字节（4G）。

**确认号（Acknowledge Number）4字节**

是期望收到对方下一个报文段的第一个数据字节的序号

**数据偏移（Data Offset）占4位 0.5个字节**

指的是 TCP 报文段的数据起始处距整个 TCP 报文段的起始处有多远。

数据偏移的单位不是字节而是32bit，因此 TCP 头部的范围为 `[20,(2^4-1)*4]` 字节，即选项长度不能超过40字节

**保留（Reserved）占6位** 目前置为0，为将来定义新的用途保留。

**控制位(ControlBits)占6位** 每一位标志可以打开一个控制功能。

- URG（Urgent Pointer Field Significant,紧急指针字段标志）:表示TCP包的紧急指针字段有效，用来保证TCP连接不被中断，并且督促中间齐备尽快处理这些数据。
- ACK（Acknowledgement field significant,确认字段标志）:取1时表示应答字段有效，也即TCP应答号将包含在TCP段中，为0则反之。
- PSH（Push Function,推功能）:这个标志表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即送给应用程序，而不是在缓冲区中排队。
- RST（Reset the connection,重置连接）：这个标志表示感谢连接复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。
- SYN（Synchronize sequence numbers,同步序列号）:表示同步序号，用来建立连接。
- FIN（No more data from sender）:表示发送端已经发送到数据末尾，数据传送完成，发送FIN标志位的TCP段，连接将被断开。

**窗口（Window）占2字节**

窗口值是`[0,2^16-1]`，窗口指的是发送本报文段的目的窗口（接收窗口）。窗口值作为接收方让发送方设置其发送窗口的数据。

简单来说就是，窗口字段用来控制对方发送的数据量，告诉对方主机它每次期望收到的数据量的字节数。最大为65kb。

**校验和（Checksum）占2字节**

校验和字段检验的范围包括首部和数据这两部分，为了证明数据的有效性。

**紧急指针（Urgent Pointer）占2字节**

这个字段只在URG标志被设置时才有效，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。

**选项（Option）**

长度可变，最长为40个字节，当没有使用长度时，TCP 首部长度为 20 个字节。

最大报文段长度MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。

**填充（Padding）**

这个字段中加入额外的零，以保证TCP头是32的整数倍。






**传输量的问题？**

1. TCP 序列号范围 [0,2^32-1]

只是个序号而已，即便发送到了2^32-1个字节，那时候第0个字节早就发送过去了，所以会重新标记序号为0。

2. TCP 每次传输包最大为65k
3. 数据链路层对数据帧的长度都有一个限制，也就是链路层所能承受的最大数据长度，这个值称为最大传输单元，即MTU 。MTU 最大长度限制为 1500 字节。
如果IP包的大小，起过了MTU值，那么就需要分片把一个IP包分为多个。


## 可靠传输原理

TCP 发送的报文段是交给 IP 层传输的，IP 层只能提供尽最大努力服务，也就是说 TCP 下面的网络所提供的是不可靠的传输，因此 TCP 需要采用适当的措施使两个运输层之间尽量可靠。

## 滑动窗口协议


## 三次握手（建立连接）

![三次握手](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-01.jpeg)

- 第一次握手 B 知晓 A  可以接收 B 可以发送
- 第二次握手 A 知晓 AB 可以发送 可以接收
- 第三次握手 B 知晓 A  可以接收 B 可以发送

## 四次挥手（关闭连接）

![四次挥手](https://wangyuchao.oss-cn-beijing.aliyuncs.com/blog/program/internet-tcp-02.jpeg)

- 第一次挥手 A 告诉 B , A 端发送数据完毕，关闭发送数据通道，准备关闭接收数据通道
- 第二次挥手 B 告诉 A , B 端已知道
- 第三次挥手 B 告诉 A , B 端发送数据完毕，关闭发送数据通道，准备关闭接收数据通道
- 第四次挥手 A 告诉 B , A 端已知道，B 端关闭接收数据通道
- 等待2MSL  A 端关闭接收数据通道

**A端为什么要等待 2MSL 的时间才关闭？**

MSL: Maximum Segment Lifetime 报文最大生存时间

- 情况一：A 发送的最后一个 ACK 报文能够到达 B 。如果第四次挥手时，如果 B 没有收到 A 的确认报文，会超时重传第三次挥手的报文。
- 情况二：防止 A 中已经失效的报文出现在这个链接中。

**B端为什么要存在一个保活状态？**

如果第三次挥手完成后，A 突然故障死机了，那 B 的连接资源什么时候能释放呢？因此 B 存在一个保活状态，就是保活时间到了后，B 会发送探测信息，以决定是否释放连接。

## 定时器







**建立连接定时器(connection-establishment timer)**

建立连接的过程中，在发送SYN时， 会启动一个定时器(默认应该是3秒)，如果SYN包丢失了， 
那么3秒以后会重新发送SYN包的(当然还会启动一个新的定时器， 设置成6秒超时)，当然也不会一直没完没了的发SYN包， 在/proc/sys/net/ipv4/tcp_syn_retries 可以设置到底要重新发送几次SYN包。

**重传定时器(retransmission timer)**

为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，
就创建这个特定报文段的重传计时器，可能发生两种情况：若在计时器超时之前收到对报文段的确认，则撤销计时器；若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位；

重传时间=2*RTT；

RTT的值应该动态计算。常用的公式是：RTT=previous RTT*i + （1-i）*current RTT。i的值通常取90%，即新的RTT是以前的RTT值的90%加上当前RTT值的10%.

Karn算法：对重传报文，在计算新的RTT时，不考虑重传报文的RTT。因为无法推理出：发送端所收到的确认是对上一次报文段的确认还是对重传报文段的确认。干脆不计入。

**延迟应答定时器(delayed ACK timer)**

延迟应答也被成为捎带ACK， 这个定时器是在延迟应答的时候使用的。 为什么要延迟应答呢？ 延迟应答是为了提高网络传输的效率。

举例说明，比如服务端收到客户端的数据后， 不是立刻回ACK给客户端， 而是等一段时间(一般最大200ms)，
这样如果服务端要是有数据需要发给客户端，那么这个ACK就和服务端的数据一起发给客户端了， 这样比立即回给客户端一个ACK节省了一个数据包。

**坚持定时器(persist timer)**

坚持定时器是使用在一方滑动窗口为0之后，另外一方停止传输数据，进入坚持定时器的轮询，直到滑动窗口不再为0了。

说说术语，首先是滑动窗口，可以简单理解为缓冲区剩余空间大小。不管是写缓冲还是读缓冲，一旦一方通告了自己的滑动窗口大小，
另外一方就会根据滑动窗口大小传递窗口大小的数据了。但是，当被通告，一方的滑动窗口大小为0的时候，另外一方就会启动坚持定时器，
基本也是使用TCP指数退避方法，第一次1.5秒，第二次1.5x2秒，第三次1.5x4...

其次是糊涂窗口综合症。这个症状是滑动窗口引起的。病因是发送方和接收方在一个很小的滑动窗口的时候就开始数据传输，
传输结束之后，读写的消费速度也并没有那么快，导致下次传输的时候，滑动窗口还是那么小。然后现象就是每次传输的数据都非常小。
就好比每次开出去的火车载货量只有一节车厢，其实我们是希望能攒够n节车厢才开始传输。

糊涂窗口综合症有解决办法，还不止一种，在接收方或者发送方都可以解决。大致就是如果接收方解决，
那么接收方在接收窗口小于一定大小的时候，对所有的接收请求都返回窗口为0的包，
来触发另外一方的坚持定时器。同样发送方也是，在可以发送的数据大于一定窗口的时候才发送。

**保活定时器(keepalive timer)**

这个就是我们经常说的tcp的keepalive了。实际使用场景是在应用层没有数据进行传输的时候，一定时间（tcp_keepalive_time，默认每2个小时）
发送一次保持心跳的包，如果发送成功，则继续保持端口活跃，如果没有正常返回，则在指定次数内（tcp_keepalive_probes，默认是9次），
指定间隔（tcp_keepalive_intvl，默认是17s）发送心跳包。如果最后都没有获得正常的ACK，那么才算连接失败。

当然，tcp是否需要提供keepalive机制，是有争议的，我们可以为每个tcp连接设置是否启用keepalive和启用keepalive的各个指标设置。

**FIN_WAIT_2定时器(FIN_WAIT_2 timer)**

主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、
被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN，主动关闭的一段总不能一直傻等着，占着资源不撒手吧？
这个时候就需要FIN_WAIT_2定时器出马了， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么不好意思， 不等了，
 直接释放这个链接。FIN_WAIT_2定时器的时间可以从/proc/sys/net/ipv4/tcp_fin_timeout中查看和设置。

**TIME_WAIT定时器 (TIME_WAIT timer, 也叫2MSL timer)**

TIME_WAIT是主动关闭连接的一端最后进入的状态， 而不是直接变成CLOSED的状态， 为什么呢？第一个原因是万一被动关闭的一端在超时时间内没有收
到最后一个ACK， 则会重发最后的FIN，2MSL（报文段最大生存时间）等待时间保证了重发的FIN会被主动关闭的一段收到且重新发送最后一个ACK；
另外一个原因是在2MSL等待时间时，任何迟到的报文段会被接收并丢弃，防止老的TCP连接的包在新的TCP连接里面出现。不可避免的，在这个2MSL等待时
间内，不会建立同样(源IP, 源端口，目的IP，目的端口)的连接。

## 流量控制

## 拥塞控制

**自动重传请求（Automatic Repeat-reQuest，ARQ）**：是OSI模型中数据链路层和传输层的错误纠正协议之一

**1. 停止等待 ARQ 协议**：每发完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。

**2. 连续 ARQ 协议**：这个协议会连续发送一组数据包，然后再等待这些数据包的ACK.

1. 回退并重传ARQ协议
- 接收点丢弃从第一个没有收到的数据包开始的所有数据包。
- 发送点收到NACK后，从NACK中指明的数据包开始重新发送。

2. 选择重传ARQ协议
- 发送点连续发送数据包但对每个数据包都设有个一个计时器。
- 当在一定时间内没有收到某个数据包的ACK时，发送点只重新发送那个没有ACK的数据包。

### 可靠传输实现

滑动窗口协议是 TCP协议 的精髓，比较复杂，这里只简单概述一下。

**以字节为单位的滑动窗口**

**超时重传**

**选择确认**

## 参考

- 《计算机网络》
- [ARQ维基百科](https://zh.wikipedia.org/wiki/ARQ)
- [TCP数据报首部](http://blog.chinaunix.net/uid-26413668-id-3408115.html)
- [TCP/IP笔记整理](http://blog.csdn.net/goodboy1881/article/category/204448)
- [三次握手四次挥手](http://blog.csdn.net/whuslei/article/details/6667471)
- [三次握手四次挥手](http://blog.csdn.net/xulu_258/article/details/51146489)
- [TCP定时器](http://www.debugrun.com/a/KqfjJer.html)