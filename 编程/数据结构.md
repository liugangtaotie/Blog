数据结构

## 排序
### 冒泡排序
```java
    /**
     * 冒泡排序
     * @param datas 源数组
     */
    public static void bubbleSort(int datas[]) {
        for (int i = 0; i < datas.length; i++) {
            for (int j = 0; j < datas.length - i - 1; j++) {
                if (datas[j] > datas[j + 1]) {
                    int temp = datas[j];
                    datas[j] = datas[j + 1];
                    datas[j + 1] = temp;
                }
            }
        }
    }
```

### 直接插入排序
```java
    /**
     * 直接插入排序
     * @param datas 源数组
     */
    public static void insertSort(int datas[]) {
        for (int i = 1; i < datas.length; i++) {
            for (int j = i - 1; j >= 0 && datas[j] > datas[j + 1]; j--) {
                int temp = datas[j + 1];
                datas[j + 1] = datas[j];
                datas[j] = temp;
            }
        }
    }
```

### 选择排序
```java
    /**
     * 选择排序
     * @param datas 源数组
     */
    public static void selectionSort(int datas[]) {
        for (int i = 0; i < datas.length; i++) {
            for (int j = i + 1; j < datas.length; j++) {
                if (datas[i] > datas[j]) {
                    int temp = datas[j];
                    datas[j] = datas[i];
                    datas[i] = temp;
                }
            }
        }
    }
```

### 快速排序
```java
public class QuickSort {
    /**
     * 快速排序
     * @param datas 源数组
     * @param start 开始位置
     * @param end 结束位置     
     */
    public void quickSort(int[] datas, int start, int end) {
        if (start < end) {
            int position = quickPass(datas, start, end);
            quickSort(datas, start, position - 1);
            quickSort(datas, position + 1, end);
        }
    }

    /**
     * 一次快速排序
     * @param datas 源数组
     * @param start 开始位置
     * @param end 结束位置
     * @return 一次快速排序后的位置
     */
    public int quickPass(int[] datas, int start, int end) {
        int tempCompare = datas[start];//取出临时数组中第一个作为比较对象
        while (start < end) {
            while (start < end && datas[end] > tempCompare) {
                end--;
            }
            if (start < end) {
                datas[start] = datas[end];
                start++;
            }
            while (start < end && datas[start] < tempCompare) {
                start++;
            }
            if (start < end) {
                datas[end] = datas[start];
                end--;
            }
        }
        datas[start] = tempCompare;
        return start;
    }

    public static void main(String[] args) {
        int[] datas = {2, 4, 32, 42, 1, 32, 23, 11, 2 };
        if (datas.length > 0) {
            new QuickSort().quickSort(datas, 0, datas.length - 1);
        }
        for (int i = 0; i < datas.length; i++) {
            System.out.print(datas[i] + " ");
        }
    }
}
```

### 归并排序
```java
public class MergeSort {

    /**
     * 归并排序
     * @param src 源数据
     * @param start 开始位置
     * @param end 结束位置
     * @param des 目标数组
     */
    public void mergeSort(int[] src, int start, int end, int[] des) {
        int[] help = new int[src.length];
        if (start == end) {
            des[start] = src[end];
        } else {
            int mid = (start + end) / 2;
            mergeSort(src, start, mid, help);
            mergeSort(src, mid + 1, end, help);
            merge(help, start, mid, end, des);
        }
    }

    /**
     * 合并src数组中的src[start-mid]和src[mid+1-end]两个数组为des
     * @param src 源数组
     * @param start 开始位置
     * @param mid 中间位置
     * @param end 结束位置
     * @param des 目的数组
     */
    public void merge(int[] src, int start, int mid, int end, int[] des) {
        int i = start;
        int j = mid + 1;
        int k = start;
        while (i <= mid && j <= end) {
            if (src[i] < src[j]) {
                des[k++] = src[i++];
            } else {
                des[k++] = src[j++];
            }
        }
        while (i <= mid) {
            des[k++] = src[i++];
        }

        while (j <= end) {
            des[k++] = src[j++];
        }
    }

    public static void main(String[] args) {
        int[] src = {4, 2, 3, 5, 1, 6, 4, 2 };//源
        int[] des = new int[src.length];
        if (src.length > 0) {
            new MergeSort().mergeSort(src, 0, src.length - 1, des);
        }
        for (int i = 0; i < des.length; i++) {
            System.out.print(des[i] + " ");
        }
    }
}
```

### 堆排序
```java
public class HeapSort {

    /**
     * 调整堆
     * @param datas 源数组
     * @param start 开始位置
     * @param end 结束位置
     */
    private static void adjustHeap(int[] datas, int start, int end) {
        int adjustData = datas[start];//需要调整的数据
        for (int i = 2 * start + 1; i <= end; i = i * 2 + 1) {
            if (i < end && datas[i] < datas[i + 1]) {//左右节点求最大
                i++;
            }
            if (adjustData >= datas[i]) {//要调整的节点比最大的还大，则不需要调整
                break;
            }
            //否则，逐层向下筛选
            datas[start] = datas[i];
            start = i;
        }
        datas[start] = adjustData;
    }

    public static void main(String[] args) {

        int[] datas = {2, 4, 32, 2, 32, 2, 32 };
        int length = datas.length;

        //建立初始堆
        for (int i = length / 2 - 1; i >= 0; i--) {
            adjustHeap(datas, i, length - 1);
        }

        //不断调整
        for (int i = length - 1; i > 0; i--) {
            int temp = datas[0];
            datas[0] = datas[i];
            datas[i] = temp;
            adjustHeap(datas, 0, i - 1);
        }

        for (int i = 0; i < datas.length; i++) {
            System.out.print(datas[i] + " ");
        }
    }
}
```

## 栈和队列
### 定义
- 先进后出和先进先出

### 两个栈实现一个队列
```java
    private Stack s1;
    private Stack s2;

    public void pushQueue(Data data) {
        s1.push(data);
    }

    public Data popQueue() {
        Data data = null;
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        data = s2.pop();
        while(!s2.isEmpty()){
            s1.push(s2.pop());
        }
        return data;
    }
```

### 两个队列实现一个栈
```java
    private Queue q1;
    private Queue q2;

    public void pushStack(Data data) {
        while (!q1.isEmpty()) {
            q2.push(q1.pop());
        }
        q1.push(data);
        while (!q2.isEmpty()) {
            q1.push(q2.pop());
        }
    }

    public Data popStack() {
        return q1.pop();
    }
```

## 链表
### 逆序输出链表
看到题目，我们很自然就想到了栈结构，当然，递归是系统栈的一种。

```java
    public void reverseLink(Link head) {
        if (head != null) {
            if (head.next != null) {
                reverseLink(head.next);
            }
            System.out.println(head.data);
        }
    }
```

上述方法同样适用于求链表倒数第K个节点问题，其实这类问题最简单的想法就是第一次遍历链表的个数，第二次走到那。这种方法跟所谓的“正确的方法”：两个指针间距K个节点遍历一次，找下个节点的次数是一致的。因此效率没有什么差别。当然如果在遍历的时候用数组存储一下的话，找到的时候会更快，但是同样的，存储赋值也会耗时。然而：**两个指针一前一后的这个方法倒是挺适合判断循环链表的情况**，链表A每次走一步，链表B每次走两步，只要链表B走到NULL的时候没有碰到与A同样的值，则不是循环链表。否则，AB肯定会碰到。

### 反转链表

```java
    public Link reverseLink(Link head) {
        Link currentNode = head;
        Link reverseHead = null;
        Link pre = null;
        while (currentNode != null) {
            pre = reverseHead;
            reverseHead = currentNode;
            reverseHead.next = pre;
            currentNode = currentNode.next;
        }
        return reverseHead;
    }
```

## 树
### 定义
- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；

### 二叉树性质
- 在非空二叉树中,第i层的结点总数不超过,i>=1;
- 深度为h的二叉树最多有 个结点(h>=1),最少有h个结点;
- 对于任意一棵二叉树，如果其叶结点数为N0,而度数为2的结点总数为N2,则N0=N2+1;
- 具有n个结点的完全二叉树的深度为「log2n」+1
- 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：
	+ 若I为结点编号则 如果I>1，则其父结点的编号为I/2;
	+ 如果2\*I <= N，则其左儿子（即左子树的根结点）的编号为2\*I；若2*I > N，则无左儿子;
	+ 如果2\*I+1 <= N，则其右儿子的结点编号为2*I+1；若2*I+1 > N，则无右儿子。

### 二叉树递归遍历
```java
void preOrder(Tree root) {
	if (root != null) {
		System.out.println(root.data);
		preOrder(root.left);
		preOrder(root.right);
	}
}
```

### 二叉树非递归遍历
```java
    /** 先序遍历 */
    void preOrder(Tree root) {
        Stack s = new Stack();
        Tree p = root;
        while (p != null || (!s.isEmpty())) {
            while (p != null) {
                System.out.println(p.data);//访问
                s.pushStack(p);
                p = p.left;
            }
            if (!s.isEmpty()) {
                p = s.popStack();
                p = p.right;
            }
        }
    }

    /** 中序遍历 */
    void inOrder(Tree root) {
        Stack s = new Stack();
        Tree p = root;
        while (p != null || (!s.isEmpty())) {
            while (p != null) {
                s.pushStack(p);
                p = p.left;
            }
            if (!s.isEmpty()) {
                p = s.popStack();
                System.out.println(p.data);//访问
                p = p.right;
            }
        }
    }

    /** 后序遍历 */
    void afterOrder(Tree root) {
        Stack s = new Stack();
        Tree p = root;
        Tree q = p;
        while (p != null || (!s.isEmpty())) {
            while (p != null) {
                s.pushStack(p);
                p = p.left;
            }
            if (!s.isEmpty()) {
                p = s.popStack();
                if (p.right == null || p.right == q) {
                    //如果没有右孩子或者右孩子已经被访问过则访问根节点
                    System.out.println(p.data);
                    q = p;
                    p = null;
                } else {
                    //如果有右孩子并且右孩子没有被访问过
                    p = p.right;
                }
            }
        }
    }
```
### 二叉树实例
#### 求二叉树中的节点个数
- 非递归解法：在push()或者pop()的时候全局变量加一
- 递归解法：二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1;//跳出条件为null时

#### 求二叉树的深度
- 非递归解法：在push()或者pop()的时候，判断栈中size并更新最大深度deepest。
- 递归解法：二叉树深度 = (左子树深度 > 右子树深度 ? 左子树深度 : 右子树深度) + 1;//跳出条件为null时

```java
    public int getDepth(Tree root) {
        if (root == null) {
            return 0;
        } else {
            int leftDepth = getDepth(root.left);
            int rightDepth = getDepth(root.right);
            return leftDepth > rightDepth ? (leftDepth + 1) : (rightDepth + 1);
        }
    }
```

#### 求二叉树最远的两个节点的长度
- 非递归解法：动态规划的一种，暂且跳过
- 递归解法：第二个程序微调即可，如下

```java
    public int getDepthTwoData(Tree root) {
        if (root == null) {
            return 0;
        } else {
            int leftDepth = getDepth(root.left);
            int rightDepth = getDepth(root.right);
            int sum = leftDepth + rightDepth;
            if (sum > largest) {
                largest = sum;
            }
            return leftDepth > rightDepth ? (leftDepth + 1) : (rightDepth + 1);
        }
    }
```

#### 层级遍历二叉树「使用队列」
```java
    public void visit(Data root) {
        queue.push(root);
        while (!queue.isEmpty()) {
            Data visitData = queue.pop();
            System.out.println(visitData.data);
            if (visitData.left != null) {
                queue.push(visitData.left);
            }
            if (visitData.right != null) {
                queue.push(visitData.right);
            }
        }
    }
```
#### 二叉树的镜像
参考：http://blog.csdn.net/luckyxiaoqiang/article/details/7518888

## 图
未完待续...